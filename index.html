<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Will You Be My Valentine?</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-user-select: none; user-select: none; }
    html, body {
      height: 100vh; width: 100%; overflow: hidden; overscroll-behavior: none;
      background: linear-gradient(135deg,#ffe4e1 0%,#ffb6c1 100%);
      font-family: Arial, sans-serif; display: flex; align-items: center; justify-content: center;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }

    .screen {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      transition: opacity 0.5s ease;
    }

    .screen.hidden { opacity: 0; pointer-events: none; }

    .letter-screen {
      flex-direction: column;
    }

    .letter {
      position: relative; cursor: pointer; animation: float 2s ease-in-out infinite;
      transition: transform 0.5s ease, opacity 0.5s ease;
    }

    .letter.open {
      transform: scale(2) translateY(-50px);
      opacity: 0;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .love-letter-img {
      width: 200px; height: auto; display: block; margin: 0 auto 20px;
      cursor: pointer;
    }

    .letter-text {
      font-size: 1.5rem; color: #d02090; font-weight: bold; text-align: center;
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .question-screen {
      background: linear-gradient(135deg,#ffe4e1 0%,#ffb6c1 100%);
    }

    .container {
      text-align: center;
      padding: calc(16px + var(--safe-top)) 20px 20px;
      z-index: 10;
      pointer-events: none;
    }

    h1 { color: #d02090; font-size: 1.9rem; margin-bottom: 10px; pointer-events: auto; }
    .question { font-size: 1.05rem; color: #c71585; margin-bottom: 18px; font-weight: bold; pointer-events: auto; }

    .buttons {
      display: flex; justify-content: center; gap: 20px; margin-top: 20px;
    }

    /* Buttons */
    button {
      border: none; border-radius: 999px; font-weight: 700; box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      transition: transform 0.12s ease-out; touch-action: none;
      -webkit-user-select: none; will-change: left, top, transform;
      pointer-events: auto;
    }

    /* Yes button smaller and placed below question */
    #yesBtn {
      background:#ff1493; color:#fff;
      padding: 14px 28px; font-size: 1.05rem;
      cursor: pointer;
    }

    /* No button larger and fixed to viewport for movement */
    #noBtn {
      background:#808080; color:#fff;
      padding: 20px 44px; font-size: 1.15rem;
      min-width: 220px; /* ensure it's visibly larger */
      height: auto;
      position: fixed; z-index: 999;
      cursor: default;
    }

    /* visually indicate non-clickable */
    #noBtn.nonclickable { opacity: 0.98; pointer-events: auto; } /* pointer-events handled in JS */

    .success {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: linear-gradient(135deg,#ff1493 0%,#ff69b4 100%); color: white; z-index: 1000; padding: 20px;
      flex-direction: column;
    }
    .success.show { display: flex; }
    .hearts { font-size: 3rem; margin-bottom: 10px; }
    .videos { display: flex; gap: 20px; margin-top: 20px; }
    .videos video { width: 200px; height: auto; }
    .gift-btn {
      position: absolute; bottom: 20px; right: 20px;
      background: #fff; color: #ff1493; padding: 10px 20px; border-radius: 20px; cursor: pointer;
      font-weight: bold; border: 2px solid #ff1493;
    }

    .voucher-screen {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: linear-gradient(135deg,#ffe4e1 0%,#ffb6c1 100%); color: white; z-index: 1100; padding: 20px;
      flex-direction: column;
    }
    .voucher-screen.show { display: flex; }
    .voucher-img { width: 300px; height: auto; margin-bottom: 20px; }
    .voucher-text { font-size: 1.5rem; text-align: center; }

    @media (max-width: 420px) {
      .buttons { flex-direction: column; gap: 10px; }
      #yesBtn { padding: 12px 24px; font-size: 1rem; }
      #noBtn  { min-width: 160px; padding: 18px 28px; font-size: 1.05rem; }
      .envelope { width: 150px; height: 105px; }
    }
  </style>
</head>
<body>
  <div class="screen letter-screen" id="letterScreen">
    <div class="letter">
      <img src="loveletter.png" alt="Love Letter" class="love-letter-img">
      <div class="letter-text">You got a letter! üíå</div>
    </div>
  </div>

  <div class="screen question-screen hidden" id="questionScreen">
    <div class="container" id="mainContainer">
      <h1>‚ù§Ô∏è Will You Be My Valentine? ‚ù§Ô∏è</h1>
      <div class="buttons">
        <button id="yesBtn" aria-label="Yes, I will">Yes! üíï</button>
        <button id="noBtn" aria-label="No, I won't" class="nonclickable" aria-disabled="true" tabindex="-1">No</button>
      </div>
    </div>
  </div>

  <div class="success" id="successScreen" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="hearts">üíï üíï üíï</div>
    <h2>Yay! I knew it! ü•∞</h2>
    <div class="videos">
      <video src="haru.mp4" autoplay loop muted></video>
      <video src="nami.mp4" autoplay loop muted></video>
    </div>
    <button class="gift-btn" id="giftBtn">Gift Voucher</button>
  </div>

  <div class="voucher-screen" id="voucherScreen" role="dialog" aria-modal="true" aria-hidden="true">
    <img src="voucher.png" alt="Voucher" class="voucher-img">
    <div class="voucher-text">This voucher can be traded for a Valentine chocolate! üç´</div>
  </div>

  <script>
    (function () {
      const letterScreen = document.getElementById('letterScreen');
      const questionScreen = document.getElementById('questionScreen');
      const envelope = document.getElementById('envelope');
      const noBtn = document.getElementById('noBtn');
      const yesBtn = document.getElementById('yesBtn');
      const success = document.getElementById('successScreen');
      const container = document.getElementById('mainContainer');

      // Letter opening animation
      const letter = document.querySelector('.letter');
      // prevent accidental taps/clicks from activating newly revealed buttons
      let suppressClicksUntil = 0;
      // block early touch/pointer events so they don't reach underlying buttons
      // Don't call preventDefault here (breaks synthetic click on some Android browsers).
      // Instead, stop propagation and set suppression window so the click handler still fires.
      letter.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        suppressClicksUntil = Date.now() + 700;
      });
      letter.addEventListener('touchstart', (e) => {
        e.stopPropagation();
        suppressClicksUntil = Date.now() + 700;
      });
      letter.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        suppressClicksUntil = Date.now() + 700; // ignore clicks for 700ms after opening
        letter.classList.add('open');
        setTimeout(() => {
          letterScreen.classList.add('hidden');
          questionScreen.classList.remove('hidden');
        }, 500);
      });

      const THROTTLE_MS = 160;
      const EDGE_PADDING = 12;
      const MAX_ATTEMPTS = 40;
      let lastMove = 0;
      let animating = false;
      let noBtnScale = 1;

      function getViewport() {
        const vv = window.visualViewport;
        if (vv) return { width: vv.width, height: vv.height, offsetLeft: vv.offsetLeft, offsetTop: vv.offsetTop };
        return { width: window.innerWidth, height: window.innerHeight, offsetLeft: 0, offsetTop: 0 };
      }

      function rectFromEl(el) { return el.getBoundingClientRect(); }

      function overlaps(r1, r2, gap = 8) {
        return !(r1.right + gap < r2.left || r1.left - gap > r2.right || r1.bottom + gap < r2.top || r1.top - gap > r2.bottom);
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // animate using requestAnimationFrame with easeOutCubic
      function animateTo(targetLeft, targetTop, duration = 420) {
        if (animating) return;
        animating = true;

        const startRect = noBtn.getBoundingClientRect();
        const vp = getViewport();
        const startLeft = startRect.left - (vp.offsetLeft || 0);
        const startTop  = startRect.top  - (vp.offsetTop || 0);

        const deltaX = targetLeft - startLeft;
        const deltaY = targetTop - startTop;
        const startTime = performance.now();

        function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

        function step(now) {
          const elapsed = now - startTime;
          const t = clamp(elapsed / duration, 0, 1);
          const eased = easeOutCubic(t);
          const curLeft = startLeft + deltaX * eased;
          const curTop  = startTop  + deltaY * eased;

          noBtn.style.left = (curLeft + (vp.offsetLeft || 0)) + 'px';
          noBtn.style.top  = (curTop  + (vp.offsetTop || 0)) + 'px';
          noBtn.style.bottom = 'auto';
          noBtn.style.right = 'auto';
          // respect current scale while animating (small pulse effect)
          noBtn.style.transform = 'translateX(0) scale(' + (noBtnScale * (1 + 0.04 * (1 - Math.abs(0.5 - eased) * 2))) + ')';

          if (t < 1) {
            requestAnimationFrame(step);
          } else {
            noBtn.style.transform = 'translateX(0) scale(' + noBtnScale + ')';
            animating = false;
          }
        }
        requestAnimationFrame(step);
      }

      function findSafePosition(btnW, btnH) {
        const vp = getViewport();
        const vw = vp.width;
        const vh = vp.height;

        const cs = getComputedStyle(document.documentElement);
        const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
        const safeRight = parseFloat(cs.getPropertyValue('--safe-right')) || 0;
        const safeTop = parseFloat(cs.getPropertyValue('--safe-top')) || 0;
        const safeBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;

        const minX = EDGE_PADDING + safeLeft;
        const maxX = Math.max(minX, vw - btnW - EDGE_PADDING - safeRight);
        const minY = EDGE_PADDING + safeTop;
        const maxY = Math.max(minY, vh - btnH - EDGE_PADDING - safeBottom);

        const yesRect = rectFromEl(yesBtn);
        const containerRect = rectFromEl(container);

        let attempt = 0;
        while (attempt < MAX_ATTEMPTS) {
          attempt++;
          // bias positions toward center under the container for initial feel
          const centerBiasX = Math.floor((maxX + minX) / 2);
          const jitterX = Math.floor((Math.random() - 0.5) * (maxX - minX) * 0.6);
          const chosenX = clamp(centerBiasX + jitterX, minX, maxX);

          // allow vertical spread but keep generally under the container
          const chosenY = Math.floor(Math.random() * (maxY - minY + 1)) + minY;

          const left = chosenX + (vp.offsetLeft || 0);
          const top  = chosenY + (vp.offsetTop || 0);
          const candidateRect = { left, top, right: left + btnW, bottom: top + btnH };

          if (!overlaps(candidateRect, yesRect, 12) && !overlaps(candidateRect, containerRect, 10)) {
            return { x: chosenX, y: chosenY };
          }
        }
        // fallback: center under container
        const fallbackX = clamp(Math.floor((vp.width - btnW) / 2), minX, maxX);
        const fallbackY = clamp(Math.floor(vp.height * 0.55), minY, maxY);
        return { x: fallbackX, y: fallbackY };
      }

      function moveNoButton() {
        const now = Date.now();
        if (now - lastMove < THROTTLE_MS) return;
        lastMove = now;

        // shrink by ~5% each time the button moves
        if (noBtn.style.display === 'none') return;
        noBtnScale *= 0.95;
        // if it's too small, hide it and stop interacting
        if (noBtnScale < 0.05) {
          noBtn.style.display = 'none';
          noBtn.style.pointerEvents = 'none';
          return;
        }
        // apply immediate scale for visual feedback
        noBtn.style.transform = 'translateX(0) scale(' + noBtnScale + ')';

        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;
        const pos = findSafePosition(btnW, btnH);
        animateTo(pos.x, pos.y, 420);
      }

      // pointerenter for mouse/pen hover; pointerdown for clicks; touchstart for touch
      noBtn.addEventListener('pointerenter', (e) => {
        if (e.pointerType === 'mouse' || e.pointerType === 'pen') moveNoButton();
      });

      noBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        moveNoButton();
      });

      noBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveNoButton();
      }, { passive: false });

      // Intercept clicks and make the button non-clickable
      noBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        // shrinking is handled each time we move the button
        moveNoButton();
      });

      // Ensure the No button remains visible after viewport changes
      function clampNoButtonToViewport() {
        const rect = noBtn.getBoundingClientRect();
        const vp = getViewport();
        const vw = vp.width;
        const vh = vp.height;
        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;

        const cs = getComputedStyle(document.documentElement);
        const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
        const safeRight = parseFloat(cs.getPropertyValue('--safe-right')) || 0;
        const safeTop = parseFloat(cs.getPropertyValue('--safe-top')) || 0;
        const safeBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;

        const minX = EDGE_PADDING + safeLeft;
        const maxX = Math.max(minX, vw - btnW - EDGE_PADDING - safeRight);
        const minY = EDGE_PADDING + safeTop;
        const maxY = Math.max(minY, vh - btnH - EDGE_PADDING - safeBottom);

        const left = clamp(rect.left - (vp.offsetLeft || 0), minX, maxX);
        const top  = clamp(rect.top  - (vp.offsetTop || 0), minY, maxY);

        noBtn.style.left = (left + (vp.offsetLeft || 0)) + 'px';
        noBtn.style.top  = (top  + (vp.offsetTop || 0)) + 'px';
        noBtn.style.bottom = 'auto';
      }

      window.addEventListener('resize', clampNoButtonToViewport);
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', clampNoButtonToViewport);
        window.visualViewport.addEventListener('scroll', clampNoButtonToViewport);
      }

      // Yes button opens success
      yesBtn.addEventListener('click', () => {
        // ignore if question screen not yet visible or still in suppression window
        if (questionScreen.classList.contains('hidden') || Date.now() < suppressClicksUntil) return;
        success.classList.add('show');
        success.setAttribute('aria-hidden', 'false');
      });
      yesBtn.addEventListener('touchend', (e) => {
        // ignore if question screen not yet visible or still in suppression window
        if (questionScreen.classList.contains('hidden') || Date.now() < suppressClicksUntil) { e.preventDefault(); return; }
        e.preventDefault();
        success.classList.add('show');
        success.setAttribute('aria-hidden', 'false');
      }, { passive: false });

      // Gift button opens voucher
      const giftBtn = document.getElementById('giftBtn');
      const voucherScreen = document.getElementById('voucherScreen');
      giftBtn.addEventListener('click', () => {
        voucherScreen.classList.add('show');
        voucherScreen.setAttribute('aria-hidden', 'false');
      });

      // initial placement: try to place the No button directly below the Yes button,
      // clamped to the viewport. If that would overlap or be offscreen, fallback to a safe random position.
      window.addEventListener('load', () => {
        const vp = getViewport();
        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;

        const yesRect = rectFromEl(yesBtn);
        const cs = getComputedStyle(document.documentElement);
        const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
        const safeRight = parseFloat(cs.getPropertyValue('--safe-right')) || 0;
        const safeTop = parseFloat(cs.getPropertyValue('--safe-top')) || 0;
        const safeBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;

        const minX = EDGE_PADDING + safeLeft;
        const maxX = Math.max(minX, vp.width - btnW - EDGE_PADDING - safeRight);
        const minY = EDGE_PADDING + safeTop;
        const maxY = Math.max(minY, vp.height - btnH - EDGE_PADDING - safeBottom);

        // center under Yes button by default
        let targetLeft = yesRect.left - (vp.offsetLeft || 0) + Math.floor((yesRect.width - btnW) / 2);
        targetLeft = clamp(targetLeft, minX, maxX);

        // place just below the Yes button
        let targetTop = clamp(yesRect.bottom - (vp.offsetTop || 0) + EDGE_PADDING, minY, maxY);

        const candidateRect = { left: targetLeft + (vp.offsetLeft || 0), top: targetTop + (vp.offsetTop || 0), right: targetLeft + (vp.offsetLeft || 0) + btnW, bottom: targetTop + (vp.offsetTop || 0) + btnH };
        const containerRect = rectFromEl(container);
        const yesElRect = rectFromEl(yesBtn);

        if (overlaps(candidateRect, containerRect, 10) || overlaps(candidateRect, yesElRect, 6)) {
          // fallback to existing safe random placement
          const pos = findSafePosition(btnW, btnH);
          noBtn.style.left = (pos.x + (vp.offsetLeft || 0)) + 'px';
          noBtn.style.top  = (pos.y + (vp.offsetTop || 0)) + 'px';
        } else {
          noBtn.style.left = (targetLeft + (vp.offsetLeft || 0)) + 'px';
          noBtn.style.top = (targetTop + (vp.offsetTop || 0)) + 'px';
        }

        noBtn.style.transform = 'translateX(0) scale(' + noBtnScale + ')';
      });

      // initial clamp
      window.requestAnimationFrame(clampNoButtonToViewport);
    })();
  </script>
</body>
</html>
