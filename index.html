<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Will You Be My Valentine?</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-user-select: none; user-select: none; }
    html, body {
      height: 100vh;
      width: 100%;
      overflow: hidden;
      overscroll-behavior: none;
      background: linear-gradient(135deg,#ffe4e1 0%,#ffb6c1 100%);
      font-family: Arial, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }

    .container {
      text-align: center;
      padding: calc(16px + var(--safe-top)) 20px 20px;
      z-index: 10;
      pointer-events: none; /* prevents accidental pointer capture by container while chasing */
    }

    h1 { color: #d02090; font-size: 1.8rem; margin-bottom: 10px; pointer-events: auto; }
    .question { font-size: 1.05rem; color: #c71585; margin-bottom: 36px; font-weight: bold; pointer-events: auto; }

    button {
      padding: 14px 28px;
      font-size: 1.05rem;
      border-radius: 999px;
      border: none;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      position: fixed;
      z-index: 999;
      transition: transform 0.12s ease-out;
      touch-action: none;
      -webkit-user-select: none;
    }

    #yesBtn { background:#ff1493; color:#fff; }
    #noBtn  { background:#808080; color:#fff; }

    /* initial positions (center bottom with safe-area offsets) */
    #yesBtn { left: calc(50% - 110px); bottom: calc(20px + var(--safe-bottom)); }
    #noBtn  { left: calc(50% + 20px); bottom: calc(20px + var(--safe-bottom)); }

    .success {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: linear-gradient(135deg,#ff1493 0%,#ff69b4 100%); color: white; z-index: 1000;
      padding: 20px;
    }
    .success.show { display: flex; flex-direction: column; }

    .hearts { font-size: 3rem; margin-bottom: 10px; }

    @media (max-width: 420px) {
      #yesBtn { left: 16px; bottom: calc(12px + var(--safe-bottom)); }
      #noBtn  { right: 16px; left: auto; bottom: calc(12px + var(--safe-bottom)); }
    }
  </style>
</head>
<body>
  <div class="container" id="mainContainer">
    <h1>‚ù§Ô∏è Will You Be My Valentine? ‚ù§Ô∏è</h1>
    <div class="question">Choose wisely...</div>
  </div>

  <button id="yesBtn" aria-label="Yes, I will">Yes! üíï</button>
  <button id="noBtn" aria-label="No, I won't">No</button>

  <div class="success" id="successScreen" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="hearts">üíï üíï üíï</div>
    <h2>Yay! I knew it! ü•∞</h2>
    <p style="margin-top:12px;">I'll see you on the 14th! ‚ù§Ô∏è</p>
  </div>

  <script>
    (function () {
      const noBtn = document.getElementById('noBtn');
      const yesBtn = document.getElementById('yesBtn');
      const success = document.getElementById('successScreen');
      const container = document.getElementById('mainContainer');

      const THROTTLE_MS = 160;
      const EDGE_PADDING = 12; // px from viewport edges
      const MAX_ATTEMPTS = 30; // attempts to find a non-overlapping spot
      let lastMove = 0;

      function getViewport() {
        const vv = window.visualViewport;
        if (vv) return { width: vv.width, height: vv.height, offsetLeft: vv.offsetLeft, offsetTop: vv.offsetTop };
        return { width: window.innerWidth, height: window.innerHeight, offsetLeft: 0, offsetTop: 0 };
      }

      function rectFromEl(el) {
        return el.getBoundingClientRect();
      }

      function overlaps(r1, r2, gap = 8) {
        return !(r1.right + gap < r2.left || r1.left - gap > r2.right || r1.bottom + gap < r2.top || r1.top - gap > r2.bottom);
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function moveNoButton() {
        const now = Date.now();
        if (now - lastMove < THROTTLE_MS) return;
        lastMove = now;

        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;

        const vp = getViewport();
        const vw = vp.width;
        const vh = vp.height;

        // safe-area insets (CSS env fallback handled by CSS; here we read computed values if present)
        const cs = getComputedStyle(document.documentElement);
        const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
        const safeRight = parseFloat(cs.getPropertyValue('--safe-right')) || 0;
        const safeTop = parseFloat(cs.getPropertyValue('--safe-top')) || 0;
        const safeBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;

        const minX = EDGE_PADDING + safeLeft;
        const maxX = Math.max(minX, vw - btnW - EDGE_PADDING - safeRight);
        const minY = EDGE_PADDING + safeTop;
        const maxY = Math.max(minY, vh - btnH - EDGE_PADDING - safeBottom);

        const yesRect = rectFromEl(yesBtn);
        const containerRect = rectFromEl(container);

        let attempt = 0;
        let chosenX = minX;
        let chosenY = minY;
        let candidateRect;

        do {
          attempt++;
          chosenX = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
          chosenY = Math.floor(Math.random() * (maxY - minY + 1)) + minY;

          // account for visualViewport offsets
          const left = chosenX + (vp.offsetLeft || 0);
          const top = chosenY + (vp.offsetTop || 0);
          candidateRect = {
            left: left,
            top: top,
            right: left + btnW,
            bottom: top + btnH
          };

          // stop if not overlapping yes button and not overlapping main container
          if (!overlaps(candidateRect, yesRect, 10) && !overlaps(candidateRect, containerRect, 8)) break;
        } while (attempt < MAX_ATTEMPTS);

        // apply position using top/left and clear bottom/right to avoid conflicts
        noBtn.style.left = (chosenX + (vp.offsetLeft || 0)) + 'px';
        noBtn.style.top  = (chosenY + (vp.offsetTop || 0)) + 'px';
        noBtn.style.bottom = 'auto';
        noBtn.style.right = 'auto';

        // small pop animation
        noBtn.style.transform = 'scale(1.06)';
        setTimeout(() => noBtn.style.transform = 'scale(1)', 120);
      }

      // pointerenter for mouse/pen hover; pointerdown for clicks; touchstart for touch
      noBtn.addEventListener('pointerenter', (e) => {
        if (e.pointerType === 'mouse' || e.pointerType === 'pen') moveNoButton();
      });

      noBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        moveNoButton();
      });

      noBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveNoButton();
      }, { passive: false });

      // If user somehow clicks "No", keep it playful but allow it
      noBtn.addEventListener('click', (e) => {
        e.preventDefault();
        moveNoButton();
      });

      yesBtn.addEventListener('click', () => {
        success.classList.add('show');
        success.setAttribute('aria-hidden', 'false');
      });

      yesBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        success.classList.add('show');
        success.setAttribute('aria-hidden', 'false');
      }, { passive: false });

      // Ensure the no button stays visible on resize / visualViewport changes
      function clampNoButtonToViewport() {
        const rect = noBtn.getBoundingClientRect();
        const vp = getViewport();
        const vw = vp.width;
        const vh = vp.height;
        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;

        const cs = getComputedStyle(document.documentElement);
        const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
        const safeRight = parseFloat(cs.getPropertyValue('--safe-right')) || 0;
        const safeTop = parseFloat(cs.getPropertyValue('--safe-top')) || 0;
        const safeBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;

        const minX = EDGE_PADDING + safeLeft;
        const maxX = Math.max(minX, vw - btnW - EDGE_PADDING - safeRight);
        const minY = EDGE_PADDING + safeTop;
        const maxY = Math.max(minY, vh - btnH - EDGE_PADDING - safeBottom);

        const left = clamp(rect.left - (vp.offsetLeft || 0), minX, maxX);
        const top  = clamp(rect.top  - (vp.offsetTop || 0), minY, maxY);

        noBtn.style.left = (left + (vp.offsetLeft || 0)) + 'px';
        noBtn.style.top  = (top  + (vp.offsetTop || 0)) + 'px';
        noBtn.style.bottom = 'auto';
      }

      window.addEventListener('resize', clampNoButtonToViewport);
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', clampNoButtonToViewport);
        window.visualViewport.addEventListener('scroll', clampNoButtonToViewport);
      }

      // initial clamp (in case CSS placed it off-screen)
      window.requestAnimationFrame(clampNoButtonToViewport);
    })();
  </script>
</body>
</html>