<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Will You Be My Valentine?</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-user-select: none; user-select: none; }
    html, body {
      height: 100vh; width: 100%; overflow: hidden; overscroll-behavior: none;
      background: linear-gradient(135deg,#ffe4e1 0%,#ffb6c1 100%);
      font-family: Arial, sans-serif; display: flex; align-items: center; justify-content: center;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
    }

    .screen {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      transition: opacity 0.5s ease;
    }

    .screen.hidden { opacity: 0; pointer-events: none; }

    .letter-screen {
      flex-direction: column;
    }

    .letter {
      position: relative; cursor: pointer; animation: float 2s ease-in-out infinite;
      transition: transform 0.5s ease, opacity 0.5s ease;
    }

    .letter.open {
      transform: scale(2) translateY(-50px);
      opacity: 0;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .love-letter-img {
      width: 200px; height: auto; display: block; margin: 0 auto 20px;
      cursor: pointer;
    }

    .letter-text {
      font-size: 1.5rem; color: #d02090; font-weight: bold; text-align: center;
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .question-screen {
      background: linear-gradient(135deg,#ffe4e1 0%,#ffb6c1 100%);
    }

    .container {
      text-align: center;
      padding: calc(16px + var(--safe-top)) 20px 20px;
      z-index: 10;
      pointer-events: none;
    }

    h1 { color: #d02090; font-size: 1.9rem; margin-bottom: 10px; pointer-events: auto; }
    .question { font-size: 1.05rem; color: #c71585; margin-bottom: 18px; font-weight: bold; pointer-events: auto; }

    .buttons {
      display: flex; justify-content: center; gap: 20px; margin-top: 20px;
    }

    /* Buttons */
    button {
      border: none; border-radius: 999px; font-weight: 700; box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      transition: transform 0.12s ease-out; touch-action: none;
      -webkit-user-select: none; will-change: left, top, transform;
      pointer-events: auto;
    }

    /* Yes button smaller and placed below question */
    #yesBtn {
      background:#ff1493; color:#fff;
      padding: 14px 28px; font-size: 1.05rem;
      min-width: 100px; /* reduced initial width */
      cursor: pointer;
    }

    /* No button larger and fixed to viewport for movement */
    #noBtn {
      background:#808080; color:#fff;
      /* slightly smaller visually by default */
      padding: 14px 34px; font-size: 1.05rem;
      min-width: 100px; /* reduced initial width */
      height: auto;
      position: fixed; z-index: 999;
      cursor: default;
    }

    /* visually indicate non-clickable */
    #noBtn.nonclickable { opacity: 0.98; pointer-events: auto; } /* pointer-events handled in JS */

    .success {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: linear-gradient(135deg,#ff1493 0%,#ff69b4 100%); color: white; z-index: 1000; padding: 20px;
      flex-direction: column;
    }
    .success.show { display: flex; }
    .hearts { font-size: 3rem; margin-bottom: 10px; }
    .videos { display: flex; gap: 20px; margin-top: 20px; }
    .videos video { width: 200px; height: auto; }
    .gift-btn {
      position: absolute; bottom: 20px; right: 20px;
      background: #fff; color: #ff1493; padding: 10px 20px; border-radius: 20px; cursor: pointer;
      font-weight: bold; border: 2px solid #ff1493;
    }

    .voucher-screen {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: linear-gradient(135deg,#ffe4e1 0%,#ffb6c1 100%); color: #b30047; z-index: 1100; padding: 20px;
      flex-direction: column; text-align: center;
    }
    .voucher-screen.show { display: flex; }

    /* Voucher challenge styles (scoped under .voucher-screen) */
    .voucher-screen .challenge-inner { position: relative; max-width: 480px; width: 100%; background: rgba(255,255,255,0.9); border-radius: 16px; padding: 20px 20px 60px; color: #4a0030; }
    .voucher-screen .challenge-inner h2 { margin: 0 0 8px; color: #d1005d; }
    .voucher-screen .challenge-inner p { margin: 0 0 16px; color: #6b2350; }
    .voucher-screen .heart-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 16px; max-width: 360px; margin: 10px auto; }
    .voucher-screen .heart { font-size: 2.5rem; cursor: pointer; user-select: none; transition: transform 0.12s ease; }
    .voucher-screen .heart:active { transform: scale(1.25); }
    .voucher-screen #voucherCode { display: none; margin-top: 18px; font-size: 1.1rem; color: #b30047; font-weight: 700; }
    /* make the voucher text appear on a single line and show the code inside a boxed monospace element */
    .voucher-screen #voucherCode { display: flex; gap: 10px; align-items: center; justify-content: center; white-space: nowrap; }
    .voucher-screen .voucher-code-box { background: #fff; border: 1px dashed rgba(179,0,71,0.25); padding: 6px 10px; border-radius: 8px; color: #b30047; font-weight: 800; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; font-size: 1rem; letter-spacing: 0.08em; box-shadow: 0 4px 10px rgba(0,0,0,0.06); display: block; margin-top: 0.25rem;}
    .voucher-screen #hint { margin-top: 14px; color: #7a5670; font-size: 0.95rem; }
    /* move the close button to bottom-left and add a separate redeem button at bottom-right */
    .voucher-screen .close-voucher { position: absolute; left: 14px; bottom: 14px; background:#ff1493; color:#fff; border:none; padding:8px 14px; border-radius:12px; cursor:pointer; font-weight:700; }
    .voucher-screen .redeem-btn { position: absolute; right: 14px; bottom: 14px; background: #fff; color: #ff1493; border: 2px solid #ff1493; padding:8px 14px; border-radius:12px; cursor:pointer; font-weight:700; }

    /* legacy placeholders removed (voucher-img / voucher-text) */
    .voucher-img { display: none; }
    .voucher-text { display: none; }

    /* Redeem screen + chocolate animation */
    .redeem-screen {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: linear-gradient(135deg,#fff5f8 0%,#ffd6e8 100%); color: #6b2350; z-index: 1200; padding: 20px;
      flex-direction: column; text-align: center;
    }
    .redeem-screen.show { display: flex; }
    .redeem-inner { max-width: 480px; width: 100%; background: rgba(255,255,255,0.95); border-radius: 16px; padding: 20px; color: #6b2350; }
    .redeem-input { width: 100%; padding: 12px 14px; font-size: 1rem; border-radius: 10px; border: 1px solid #e0b9c9; margin-top: 12px; }
    /* make Redeem and Back buttons inside the redeem card the same size */
    .redeem-inner .close-voucher,
    .redeem-inner .redeem-submit {
      margin-top: 12px; padding: 10px 18px; min-width: 120px; border-radius: 10px; font-weight: 700; font-size: 1rem;
      display: inline-block; box-sizing: border-box; text-align: center;
    }
    .redeem-inner .redeem-submit { background: #ff1493; color: #fff; border: none; cursor: pointer; }
    .redeem-inner .close-voucher { background: #fff; color: #ff1493; border: 2px solid #ff1493; cursor: pointer; }

    .chocolate { display: block; margin: 18px auto 0; width: 160px; height: auto; opacity: 0; transform: scale(.9); transition: opacity .25s ease; }
    .chocolate.show { opacity: 1; animation: chocolate-pulse 1.2s ease-in-out infinite; }
    @keyframes chocolate-pulse { 0% { transform: scale(0.92); } 50% { transform: scale(1.14); } 100% { transform: scale(0.92); } }

    @media (max-width: 420px) {
      .buttons { flex-direction: column; gap: 10px; }
      #yesBtn { padding: 12px 24px; font-size: 1rem; }
      #noBtn  { min-width: 160px; padding: 18px 28px; font-size: 1.05rem; }
      .envelope { width: 150px; height: 105px; }
    }
    
    .music-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.8);
      border: none;
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
    }

    .message-screen {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      z-index: 1050; padding: 30px; text-align: center;
      /* Eiffel Tower Background */
      background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), url('eiffell.jpg');
      background-size: cover;
      background-position: center;
    }

    .message-screen.show { display: flex; }

    .message-content {
      max-width: 600px;
      backdrop-filter: blur(8px); /* Blurs the background image */
      -webkit-backdrop-filter: blur(8px);
      background: rgba(255, 255, 255, 0.15); /* Semi-transparent overlay */
      padding: 40px 30px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    .romantic-text {
      font-family: 'Georgia', serif; /* Or 'Dancing Script' if you link a Google Font */
      font-style: italic;
      font-size: 1.4rem;
      line-height: 1.6;
      color: #ffffff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      margin-bottom: 30px;
    }

    .next-to-voucher-btn {
      background: #ff1493;
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 999px;
      font-weight: bold;
      font-size: 1.1rem;
      cursor: pointer;
      transition: transform 0.2s ease;
      position: absolute;
      bottom: 20px;
      right: 20px;
    }

    .next-to-voucher-btn:active { transform: scale(0.95); }

    @media (max-width: 480px) {
      .romantic-text { font-size: 1.1rem; }
    }

  </style>
</head>
<body>
  <audio id="bgm" loop autoplay>
    <source src="Liebestraum.mp3" type="audio/mpeg">
  </audio>
    <div class="screen letter-screen" id="letterScreen">
      <div class="letter">
        <img src="loveletter.png" alt="Love Letter" class="love-letter-img">
        <div class="letter-text">You got a letter! üíå</div>
        
      </div>
      <button id="toggleMusic" class="music-btn">üéµ Music</button>
    </div>

    <div class="screen question-screen hidden" id="questionScreen">
      <div class="container" id="mainContainer">
        <h1>‚ù§Ô∏è Will You Be My Valentine? ‚ù§Ô∏è</h1>
        <div class="buttons">
          <button id="yesBtn" aria-label="Yes, I will">Yes! üíï</button>
          <button id="noBtn" aria-label="No, I won't" class="nonclickable" aria-disabled="true" tabindex="-1">No</button>
        </div>
      </div>
    </div>

    <div class="success" id="successScreen" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="hearts">üíï üíï üíï</div>
      <h2>Yay! I knew it! ü•∞</h2>
      <div class="videos">
        <video src="haru.mp4" autoplay loop muted></video>
        <video src="nami.mp4" autoplay loop muted></video>
      </div>
      <button class="gift-btn" id="giftBtn">I have something to tell you</button>
    </div>

    <div class="message-screen" id="messageScreen" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="message-content">
        <p class="romantic-text">
          "Happy Valentine's Day! 
          Thank you for every moment ‚Äî the quiet ones, the silly ones, the magical ones, 
          and even the hard ones we got through together. I‚Äôm grateful for the way you love me, 
          for the memories we‚Äôve built, and for the life we‚Äôre still creating side by side. 
          I love you, and I‚Äôm thankful for every year, every day, every little moment with you."
        </p>
      </div>
      <button class="next-to-voucher-btn" id="toVoucherBtn">Want another Surprise?</button>
    </div>

    <div class="voucher-screen" id="voucherScreen" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="challenge-inner" role="document" aria-labelledby="voucherTitle">
        <h2 id="voucherTitle">Pick the Heart That Loves You Back</h2>
        <p>One of these hearts hides your Valentine voucher. But the right one needs a little extra love.</p>

        <div class="heart-container" id="heartContainer">
          <!-- all hearts show the same glyph to make the secret indistinguishable -->
          <span class="heart" data-secret="false" aria-hidden="false">‚ù§Ô∏è</span>
          <span class="heart" data-secret="false" aria-hidden="false">‚ù§Ô∏è</span>
          <span class="heart" data-secret="false" aria-hidden="false">‚ù§Ô∏è</span>
          <span class="heart" data-secret="false" aria-hidden="false">‚ù§Ô∏è</span>
          <span class="heart" data-secret="false" aria-hidden="false">‚ù§Ô∏è</span>
        </div>

        <div id="voucherCode">üéâ Congratulations! Your voucher: <span class="voucher-code-box" role="status" aria-live="polite"><code>I-LOVE-KEVIN</code></span></div>
        <div id="hint">Hint: Some hearts take time to open up.</div>
        <button class="close-voucher" id="closeVoucherBtn">Close</button>
        <button class="redeem-btn" id="redeemBtn">Redeem</button>
      </div>
    </div>

    <div class="redeem-screen" id="redeemScreen" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="redeem-inner" role="document" aria-labelledby="redeemTitle">
        <h2 id="redeemTitle">Redeem Your Voucher</h2>
        <p>Enter your voucher code to claim your Gift.</p>
        <input id="redeemInput" class="redeem-input" placeholder="Enter voucher code" aria-label="Voucher code">
        <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
          <button id="redeemBack" class="close-voucher" style="background:#fff;color:#ff1493;border:2px solid #ff1493;">Back</button>
          <button id="redeemSubmit" class="redeem-submit">Redeem</button>
        </div>
        <img src="chocolate.png" alt="Chocolate" id="chocolateImg" class="chocolate" />
        <div id="redeemMsg" style="margin-top:10px;color:#6b2350;font-weight:700;"></div>
      </div>
    </div>

  
  

  <script>

    const bgm = document.getElementById('bgm');
    const btn = document.getElementById('toggleMusic');

    document.addEventListener('click', () => {
      if (bgm.paused) {
        bgm.volume = 0.25; // soft and romantic
        bgm.play();
      }
    }, { once: true });

    btn.addEventListener('click', () => {
      if (bgm.paused) {
        bgm.play();
        btn.textContent = "üéµ Music";
      } else {
        bgm.pause();
        btn.textContent = "üîá Music";
      }
    });

    (function () {
      const letterScreen = document.getElementById('letterScreen');
      const questionScreen = document.getElementById('questionScreen');
      const envelope = document.getElementById('envelope');
      const noBtn = document.getElementById('noBtn');
      const yesBtn = document.getElementById('yesBtn');
      const success = document.getElementById('successScreen');
      const container = document.getElementById('mainContainer');

      // Letter opening animation
      const letter = document.querySelector('.letter');
      // prevent accidental taps/clicks from activating newly revealed buttons
      let suppressClicksUntil = 0;
      // block early touch/pointer events so they don't reach underlying buttons
      // Don't call preventDefault here (breaks synthetic click on some Android browsers).
      // Instead, stop propagation and set suppression window so the click handler still fires.
      letter.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        suppressClicksUntil = Date.now() + 700;
      });
      letter.addEventListener('touchstart', (e) => {
        e.stopPropagation();
        suppressClicksUntil = Date.now() + 700;
      });
      letter.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        suppressClicksUntil = Date.now() + 700; // ignore clicks for 700ms after opening
        letter.classList.add('open');
        setTimeout(() => {
          letterScreen.classList.add('hidden');
          questionScreen.classList.remove('hidden');
        }, 500);
      });

      const THROTTLE_MS = 160;
      const EDGE_PADDING = 12;
      const MAX_ATTEMPTS = 40;
      let lastMove = 0;
      let animating = false;
      // start slightly smaller than full size
      let noBtnScale = 0.90;

      function getViewport() {
        const vv = window.visualViewport;
        if (vv) return { width: vv.width, height: vv.height, offsetLeft: vv.offsetLeft, offsetTop: vv.offsetTop };
        return { width: window.innerWidth, height: window.innerHeight, offsetLeft: 0, offsetTop: 0 };
      }

      function rectFromEl(el) { return el.getBoundingClientRect(); }

      function overlaps(r1, r2, gap = 8) {
        return !(r1.right + gap < r2.left || r1.left - gap > r2.right || r1.bottom + gap < r2.top || r1.top - gap > r2.bottom);
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // animate using requestAnimationFrame with easeOutCubic
      function animateTo(targetLeft, targetTop, duration = 420) {
        if (animating) return;
        animating = true;

        const startRect = noBtn.getBoundingClientRect();
        const vp = getViewport();
        const startLeft = startRect.left - (vp.offsetLeft || 0);
        const startTop  = startRect.top  - (vp.offsetTop || 0);

        const deltaX = targetLeft - startLeft;
        const deltaY = targetTop - startTop;
        const startTime = performance.now();

        function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

        function step(now) {
          const elapsed = now - startTime;
          const t = clamp(elapsed / duration, 0, 1);
          const eased = easeOutCubic(t);
          const curLeft = startLeft + deltaX * eased;
          const curTop  = startTop  + deltaY * eased;

          noBtn.style.left = (curLeft + (vp.offsetLeft || 0)) + 'px';
          noBtn.style.top  = (curTop  + (vp.offsetTop || 0)) + 'px';
          noBtn.style.bottom = 'auto';
          noBtn.style.right = 'auto';
          // respect current scale while animating (small pulse effect)
          noBtn.style.transform = 'translateX(0) scale(' + (noBtnScale * (1 + 0.04 * (1 - Math.abs(0.5 - eased) * 2))) + ')';

          if (t < 1) {
            requestAnimationFrame(step);
          } else {
            noBtn.style.transform = 'translateX(0) scale(' + noBtnScale + ')';
            animating = false;
          }
        }
        requestAnimationFrame(step);
      }

      function findSafePosition(btnW, btnH) {
        const vp = getViewport();
        const vw = vp.width;
        const vh = vp.height;

        const cs = getComputedStyle(document.documentElement);
        const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
        const safeRight = parseFloat(cs.getPropertyValue('--safe-right')) || 0;
        const safeTop = parseFloat(cs.getPropertyValue('--safe-top')) || 0;
        const safeBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;

        const minX = EDGE_PADDING + safeLeft;
        const maxX = Math.max(minX, vw - btnW - EDGE_PADDING - safeRight);
        const minY = EDGE_PADDING + safeTop;
        const maxY = Math.max(minY, vh - btnH - EDGE_PADDING - safeBottom);

        const yesRect = rectFromEl(yesBtn);
        const containerRect = rectFromEl(container);

        let attempt = 0;
        while (attempt < MAX_ATTEMPTS) {
          attempt++;
          // bias positions toward center under the container for initial feel
          const centerBiasX = Math.floor((maxX + minX) / 2);
          const jitterX = Math.floor((Math.random() - 0.5) * (maxX - minX) * 0.6);
          const chosenX = clamp(centerBiasX + jitterX, minX, maxX);

          // allow vertical spread but keep generally under the container
          const chosenY = Math.floor(Math.random() * (maxY - minY + 1)) + minY;

          const left = chosenX + (vp.offsetLeft || 0);
          const top  = chosenY + (vp.offsetTop || 0);
          const candidateRect = { left, top, right: left + btnW, bottom: top + btnH };

          if (!overlaps(candidateRect, yesRect, 12) && !overlaps(candidateRect, containerRect, 10)) {
            return { x: chosenX, y: chosenY };
          }
        }
        // fallback: center under container
        const fallbackX = clamp(Math.floor((vp.width - btnW) / 2), minX, maxX);
        const fallbackY = clamp(Math.floor(vp.height * 0.55), minY, maxY);
        return { x: fallbackX, y: fallbackY };
      }

      function moveNoButton() {
        const now = Date.now();
        if (now - lastMove < THROTTLE_MS) return;
        lastMove = now;

        // shrink by ~10% each time the button moves (faster disappearance)
        if (noBtn.style.display === 'none') return;
        noBtnScale *= 0.90;
        // if it's too small, hide it and stop interacting
        if (noBtnScale < 0.05) {
          noBtn.style.display = 'none';
          noBtn.style.pointerEvents = 'none';
          return;
        }
        // apply immediate scale for visual feedback
        noBtn.style.transform = 'translateX(0) scale(' + noBtnScale + ')';

        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;
        const pos = findSafePosition(btnW, btnH);
        animateTo(pos.x, pos.y, 420);
      }

      // pointerenter for mouse/pen hover; pointerdown for clicks; touchstart for touch
      noBtn.addEventListener('pointerenter', (e) => {
        if (e.pointerType === 'mouse' || e.pointerType === 'pen') moveNoButton();
      });

      noBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        moveNoButton();
      });

      noBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveNoButton();
      }, { passive: false });

      // Intercept clicks and make the button non-clickable
      noBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        // shrinking is handled each time we move the button
        moveNoButton();
      });

      // Ensure the No button remains visible after viewport changes
      function clampNoButtonToViewport() {
        const rect = noBtn.getBoundingClientRect();
        const vp = getViewport();
        const vw = vp.width;
        const vh = vp.height;
        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;

        const cs = getComputedStyle(document.documentElement);
        const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
        const safeRight = parseFloat(cs.getPropertyValue('--safe-right')) || 0;
        const safeTop = parseFloat(cs.getPropertyValue('--safe-top')) || 0;
        const safeBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;

        const minX = EDGE_PADDING + safeLeft;
        const maxX = Math.max(minX, vw - btnW - EDGE_PADDING - safeRight);
        const minY = EDGE_PADDING + safeTop;
        const maxY = Math.max(minY, vh - btnH - EDGE_PADDING - safeBottom);

        const left = clamp(rect.left - (vp.offsetLeft || 0), minX, maxX);
        const top  = clamp(rect.top  - (vp.offsetTop || 0), minY, maxY);

        noBtn.style.left = (left + (vp.offsetLeft || 0)) + 'px';
        noBtn.style.top  = (top  + (vp.offsetTop || 0)) + 'px';
        noBtn.style.bottom = 'auto';
      }

      window.addEventListener('resize', clampNoButtonToViewport);
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', clampNoButtonToViewport);
        window.visualViewport.addEventListener('scroll', clampNoButtonToViewport);
      }

      // Yes button opens success
      yesBtn.addEventListener('click', () => {
        // ignore if question screen not yet visible or still in suppression window
        if (questionScreen.classList.contains('hidden') || Date.now() < suppressClicksUntil) return;
        success.classList.add('show');
        success.setAttribute('aria-hidden', 'false');
      });
      yesBtn.addEventListener('touchend', (e) => {
        // ignore if question screen not yet visible or still in suppression window
        if (questionScreen.classList.contains('hidden') || Date.now() < suppressClicksUntil) { e.preventDefault(); return; }
        e.preventDefault();
        success.classList.add('show');
        success.setAttribute('aria-hidden', 'false');
      }, { passive: false });

      // // Gift button opens voucher
      // const giftBtn = document.getElementById('giftBtn');
      // const voucherScreen = document.getElementById('voucherScreen');
      // giftBtn.addEventListener('click', () => {
      //   // reset challenge state each time the modal is opened
      //   resetVoucherChallenge();
      //   voucherScreen.classList.add('show');
      //   voucherScreen.setAttribute('aria-hidden', 'false');
      // });

      const giftBtn = document.getElementById('giftBtn');
      const messageScreen = document.getElementById('messageScreen');
      const toVoucherBtn = document.getElementById('toVoucherBtn');
      const voucherScreen = document.getElementById('voucherScreen');

      // 1. Success Screen "Want next challenge?" button now goes to Message Screen
      giftBtn.addEventListener('click', () => {
        success.classList.remove('show'); // Hide success
        messageScreen.classList.add('show');
        messageScreen.setAttribute('aria-hidden', 'false');
      });

      // 2. New Message Screen button goes to Voucher Screen
      toVoucherBtn.addEventListener('click', () => {
        messageScreen.classList.remove('show');
        resetVoucherChallenge(); // Resets the heart game
        voucherScreen.classList.add('show');
        voucherScreen.setAttribute('aria-hidden', 'false');
      });

      // --- Voucher challenge logic ---
      const heartContainer = document.getElementById('heartContainer');
      const voucherCodeEl = document.getElementById('voucherCode');
      const hintEl = document.getElementById('hint');
      const closeVoucherBtn = document.getElementById('closeVoucherBtn');
      let secretClicks = 0;

      function resetVoucherChallenge() {
        secretClicks = 0;
        voucherCodeEl.style.display = 'none';
        hintEl.textContent = 'Hint: Some hearts take time to open up.';
        // ensure hearts are enabled and *randomly* choose the secret heart each reset
        const hearts = Array.from(heartContainer.querySelectorAll('.heart'));
        hearts.forEach(h => {
          h.style.opacity = '1';
          h.setAttribute('data-secret', 'false');
        });
        const secretIndex = Math.floor(Math.random() * hearts.length);
        hearts[secretIndex].setAttribute('data-secret', 'true');
        // keep the existing (hard) tap requirement ‚Äî currently set to 10
        secretClicks = 0;
      }

      function tryRevealHeart(isSecret) {
        if (!isSecret) {
          hintEl.textContent = 'Nope ‚Äî try another heart!';
          return;
        }

        secretClicks++;
        if (secretClicks < 10) {
          hintEl.textContent = 'This heart feels special‚Ä¶ try tapping it again.';
        } else {
          voucherCodeEl.style.display = 'block';
          hintEl.textContent = 'Voucher revealed ‚Äî enjoy!';
        }
      }

      // delegate clicks inside the heart container
      heartContainer.addEventListener('click', (e) => {
        const heart = e.target.closest('.heart');
        if (!heart) return;
        const isSecret = heart.getAttribute('data-secret') === 'true';
        tryRevealHeart(isSecret);
      });

      closeVoucherBtn.addEventListener('click', () => {
        voucherScreen.classList.remove('show');
        voucherScreen.setAttribute('aria-hidden', 'true');
      });

      // Redeem flow: open a small redeem screen where user can type voucher code
      const redeemBtnEl = document.getElementById('redeemBtn');
      const redeemScreen = document.getElementById('redeemScreen');
      const redeemInput = document.getElementById('redeemInput');
      const redeemSubmit = document.getElementById('redeemSubmit');
      const redeemBack = document.getElementById('redeemBack');
      const chocolateImg = document.getElementById('chocolateImg');
      const redeemMsg = document.getElementById('redeemMsg');

      redeemBtnEl.addEventListener('click', () => {
        // move to redeem screen
        voucherScreen.classList.remove('show');
        voucherScreen.setAttribute('aria-hidden', 'true');
        redeemScreen.classList.add('show');
        redeemScreen.setAttribute('aria-hidden', 'false');
        redeemInput.value = '';
        redeemMsg.textContent = '';
        chocolateImg.classList.remove('show');
        redeemInput.focus();
      });

      redeemBack.addEventListener('click', () => {
        redeemScreen.classList.remove('show');
        redeemScreen.setAttribute('aria-hidden', 'true');
        voucherScreen.classList.add('show');
        voucherScreen.setAttribute('aria-hidden', 'false');
      });

      function checkVoucherCode() {
        const v = (redeemInput.value || '').trim();

        if (v === 'I-LOVE-KEVIN') {
          redeemMsg.textContent = 'Voucher accepted ‚Äî enjoy your special gift!';
          chocolateImg.classList.add('show');
        } else {
          redeemMsg.textContent = 'Invalid voucher ‚Äî try again.';
          chocolateImg.classList.remove('show');
        }
      }

      redeemSubmit.addEventListener('click', checkVoucherCode);
      redeemInput.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') checkVoucherCode(); });

      // initial placement: try to place the No button directly below the Yes button,
      // clamped to the viewport. If that would overlap or be offscreen, fallback to a safe random position.
      window.addEventListener('load', () => {
        const vp = getViewport();
        const btnW = noBtn.offsetWidth;
        const btnH = noBtn.offsetHeight;

        const yesRect = rectFromEl(yesBtn);
        const cs = getComputedStyle(document.documentElement);
        const safeLeft = parseFloat(cs.getPropertyValue('--safe-left')) || 0;
        const safeRight = parseFloat(cs.getPropertyValue('--safe-right')) || 0;
        const safeTop = parseFloat(cs.getPropertyValue('--safe-top')) || 0;
        const safeBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;

        const minX = EDGE_PADDING + safeLeft;
        const maxX = Math.max(minX, vp.width - btnW - EDGE_PADDING - safeRight);
        const minY = EDGE_PADDING + safeTop;
        const maxY = Math.max(minY, vp.height - btnH - EDGE_PADDING - safeBottom);

        // horizontally center under the Yes button, but force the initial vertical
        // position to the bottom of the viewport (so No starts at the bottom).
        let targetLeft = yesRect.left - (vp.offsetLeft || 0) + Math.floor((yesRect.width - btnW) / 2);
        targetLeft = clamp(targetLeft, minX, maxX);

        // place at the bottom of the viewport (respecting safe area / padding)
        let targetTop = maxY;

        const candidateRect = { left: targetLeft + (vp.offsetLeft || 0), top: targetTop + (vp.offsetTop || 0), right: targetLeft + (vp.offsetLeft || 0) + btnW, bottom: targetTop + (vp.offsetTop || 0) + btnH };
        const containerRect = rectFromEl(container);
        const yesElRect = rectFromEl(yesBtn);

        // if the bottom-centered candidate overlaps the main container or the Yes button,
        // fall back to the safe random placement (keeps behavior robust on very small screens)
        if (overlaps(candidateRect, containerRect, 10) || overlaps(candidateRect, yesElRect, 6)) {
          const pos = findSafePosition(btnW, btnH);
          // prefer positions near the bottom if possible
          const fallbackY = clamp(Math.max(pos.y, maxY - Math.floor(btnH * 1.2)), minY, maxY);
          noBtn.style.left = (pos.x + (vp.offsetLeft || 0)) + 'px';
          noBtn.style.top  = (fallbackY + (vp.offsetTop || 0)) + 'px';
        } else {
          noBtn.style.left = (targetLeft + (vp.offsetLeft || 0)) + 'px';
          noBtn.style.top = (targetTop + (vp.offsetTop || 0)) + 'px';
        }

        noBtn.style.transform = 'translateX(0) scale(' + noBtnScale + ')';
      });

      // initial clamp
      window.requestAnimationFrame(clampNoButtonToViewport);
    })();
  </script>
</body>
</html>
